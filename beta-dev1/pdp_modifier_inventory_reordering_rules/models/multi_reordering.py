from odoo import models, fields, api
from odoo.addons import decimal_precision as dp

class multi_reordering_rule(models.Model):
    _name = 'stock.multi.reordering'

    name = fields.Char(
        'Name', copy=False, required=True,
        default=lambda self: self.env['ir.sequence'].next_by_code('stock.orderpoint'))
    active = fields.Boolean(
        'Active', default=True,
        help="If the active field is set to False, it will allow you to hide the orderpoint without removing it.")
    type = fields.Selection([('shop','Shop'),('warehouse','Warehouse')],required=True,default='shop')
    location_id = fields.Many2one(
        'stock.location', 'Location',
        ondelete="cascade", required=True)
    procurement_ids = fields.One2many('procurement.order', 'orderpoint_id', 'Created Procurements')
    group_id = fields.Many2one(
        'procurement.group', 'Procurement Group', copy=False,
        help="Moves created through this orderpoint will be put in this procurement group. If none is given, the moves generated by procurement rules will be grouped into one big picking.")
    company_id = fields.Many2one(
        'res.company', 'Company', required=True,
        default=lambda self: self.env['res.company']._company_default_get('stock.warehouse.orderpoint'))
    lead_days = fields.Integer(
        'Lead Time', default=1,
        help="Number of days after the orderpoint is triggered to receive the products or to order to the vendor")
    lead_type = fields.Selection(
        [('net', 'Day(s) to get the products'), ('supplier', 'Day(s) to purchase')], 'Lead Type',
        required=True, default='supplier')
    line_ids = fields.One2many('stock.reordering.line',inverse_name='reordering_id')

    @api.onchange('type')
    def domain_type_location(self):
        if self.type:
            if self.type == 'shop':
                return {'domain': {'location_id': [('is_shop','=',True)]}}
            else:
                return {'domain': {'location_id': [('is_shop', '=', False)]}}

class multi_reordering_rule_line(models.Model):
    _name = 'stock.reordering.line'

    reordering_id = fields.Many2one('stock.multi.reordering')
    code        = fields.Selection('_get_internal_ref','Code',required=True)
    product_id  = fields.Many2one('product.product','Product',required=True)
    categ_id    = fields.Many2one('product.category','Category',required=True)
    movement    = fields.Selection([('new','New'),('discontinue','Discontinue'),('running','Running'),('slow','Slow')],string='Movement',required=True)
    product_min_qty = fields.Float('Minimum Quantity',required=True)
    product_max_qty = fields.Float('Maximum Quantity')
    qty_multiple    = fields.Float('Quantity Multiple')
    sale_price         = fields.Float('Sales Price',readonly=True,related='product_id.list_price')
    previous_min_qty   = fields.Float('Previous Minimum Quantity',readonly=True,)
    previous_min_price = fields.Float('Previous Minimum Price',readonly=True,compute='get_min_price')
    product_uom     = fields.Many2one('product.uom', 'Product Unit of Measure',required=True, )

    @api.model
    def _get_internal_ref(self):
        res = []
        for record in self.env['product.product'].search([]).mapped('default_code'):
            res.append((record,record))
        return res

    @api.onchange('code')
    def change_product_code(self):
        if self.code:
            product_ids = self.env['product.product'].search([('default_code','=',self.code)])
            if product_ids:
                self.product_id = product_ids[0].id
                self.categ_id = product_ids[0].categ_id.id or False
                self.movement = product_ids[0].product_tmpl_id.movement
                self.product_uom = product_ids[0].uom_id.id or False

    @api.onchange('product_id')
    def change_code_product(self):
        if self.product_id:
            self.code = self.product_id.default_code
            self.categ_id = self.product_id.categ_id.id or False
            self.movement = self.product_id.product_tmpl_id.movement
            self.product_uom = self.product_id.uom_id.id or False

    @api.depends('sale_price','product_min_qty')
    def get_min_price(self):
        for record in self:
            record.previous_min_price = record.sale_price * record.product_min_qty
